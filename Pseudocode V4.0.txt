Pseudo Code Done:
- delay
- curBoard
- gameLogic
- bufferToNum
- boardToChar
- altTurn
- draw
- win
- putInBoard
- gameState
- legalMoves
- max
- min
- minimax
- largemin


FUNCTION delay(number_of_seconds)
    milli_seconds <-- 1000 * number_of_seconds
    start_time <-- clock()
    WHILE (clock() < start_time + milli_seconds)

    END WHILE
END FUNCTION

FUNCTION curBoard(int from[], int to[])
    FOR(int i = 0; i < 9; i++)
        to[i] <-- from[i]
    END FOR
END FUNCTION


FUNCTION gameLogic(board, mode)
    gs <-- gameState(board)
    IF (gs == X)
        tictactoeWindow(board, turn, 'X')
        PRINT "X won!"
    END IF
    ELSE IF (gs == O)
        tictactoeWindow(board, turn, 'O')
        PRINT "O won!"
    END IF
    ELSE IF (gs == 0)
        tictactoeWindow (board, turn, 'D');
        PRINT "it is a draw!"
    END IF
    ELSE
        IF (mode == 1)
            altTurn()
            tictactoeWindow(board, turn, ' ')
        END IF
        ELSE
            altTurn()
            PRINT "Player X or O Turn"
            IF (turn == O)
                tictactoeWindow(board, turn, ' ')
            END IF
            ELSE
                random <-- rand() % difficulty
                PRINT random generated value
                PRINT "Computer is thinking"
                delay(delay value)
                IF (random != 1)
                    rand() % difficulty
                    PRINT output
                    output <-- 0
                END IF
                ELSE
                    putInBoard(board, badai(board, 8), X)
                END IF
                gameLogic(board, mode)
            END IF
        END IF
    END IF
END FUNCTION


FUNCTION bufferToNum(buffer[])
    n <-- 0 
    FOR i = 0 to list length do
        n <-- 10 * n + buffer[i] - '0'
    END FOR
    return n
END FUNCTION

FUNCTION boardToChar(i)
    a <-- board[i]
    IF a == X do
        return 'X'
    END IF
    ELSE IF a == O do
        return 'O'
    END IF
    ELSE
        return a + '0'
    END IF
END FUNCTION


FUNCTION altTurn
    IF turn == O do 
        turn <-- x
    END IF
    ELSE IF turn == X do
        turn <-- O
    END IF 
END FUNCTION

FUNCTION draw(l_board[])
    FOR i = o to i = 8 do
        IF (l_board[i] == i+1) do
            return 0;
        END IF
    END FOR
    return 1;
END FUNCTION

FUNCTION win(l_board[])
    FOR i = 0 to 2 do
        IF (l_board[3*i] == l_board[3*i + 1] && l_board[3*i + 1] == l_board[3*i + 2])
            return l_board[3*i]
        END IF
    END FOR
    FOR i = 0 to 2 do
        IF (l_board[j] == l_board[3 + j] && l_board[3 + j] == l_board[6 + j])
            return l_board[j]
        END IF
    END FOR
    IF (l_board[0] == l_board[4] && l_board[0] == l_board[8])
        return l_board[0]
    END IF
    IF (l_board[2] == l_board[4] && l_board[2] == l_board[6])
        return l_board[2]
    END IF
    return 0
END FUNCTION

FUNCTION putInBoard(l_board[], pos, newVal)
    IF (l_board[pos] == pos+1)
        l_board[pos] = newVal
        return 1
    END IF
    ELSE
        return 0
    END IF
END FUNCTION

FUNCTION gameState(l_board[])
    wc <-- win(l_board)
    IF (wc == X)
        return x
    END IF
    ELSE IF(wc == O)
        return O
    END IF
    ELSE
        IF draw(l_board)
            return 0
        END IF
    END IF
    return 1
END FUNCTION

FUNCTION legalMoves(l_board[], output[])
    FOR i = 0 to 8
        IF (l_board[i] == i+1)
            output[i] = 1
        END IF
        ELSE
            output[i] =  0
        END IF
    END FOR
END FUNCTION

FUNCTION max(a, b)
    IF a>b
        return a
    END IF
    ELSE
        return b
    END IF
END FUNCTION

FUNCTION min(a, b)
    IF a<b
        return a
    END IF
    ELSE
        return b
    END IF
END FUNCTION

FUNCTION minimax(l_board[], depth, maximising)
    gs <-- gameState(l_board)
    output <-- output + 1
    IF gs == X
        return 10
    END IF
    ELSE IF gs == O
        return -10
    END IF
    ELSE IF gs == 0
        return 0
    END IF
    IF depth == 0 do
        return 0
    END IF
    IF (maximising)
        val <-- -100
        legalMovesArr[9]
        legalMoves(l_board, legalMovesArr)
        FOR i = 0 to i = 8 do
            IF (legalMovesArr[i])
                tempBoard[9]
                curBoard(l_board, tempBoard)
                putInBoard(tempBoard, i, X)
                val = max(minimax(tempBoard, depth-1, 0), val)
            END IF
        END FOR 
        return val
    END IF
    ELSE
        val <-- 100
        legalMovesArr[9]
        legalMoves(l_board, legalMovesArr)
        FOR i = 0 to i = 8 do 
            IF (legalMovesArr[i])
                tempBoard[9]
                curBoard(l_board, tempBoard)
                putInBoard(tempBoard, i, O)
                val = min(minimax(tempBoard, depth-1, 1), val)
            END IF
        END FOR
        return val
    END IF
END FUNCTION
    
FUNCTION largemin(l_board[], depth, maximising)
    gs <-- gameState(l_board)
    output <-- output + 1
    IF(gs == O)
        return 10;
    END IF
    ELSE IF (gs == X)
        return -10
    END IF
    ELSE IF (gs == 0)
        return 0
    END IF
    IF (depth == 0)
        return 0;
    END IF
    IF (maximise)
        val <-- -100
        legalMovesArr[9]
        legalMoves(l_board, legalMovesArr)
        FOR i = 0 to i = 8 do
            IF (legalMovesArr[i])
                tempBoard[9]
                curBoard(l_board, tempBoard)
                putInBoard(tempBoard, i, X)
                val = max(largemin(tempBoard, depth-1, 0), val)
            END IF
        END FOR
        return val
    END IF
    ELSE 
        val = 100
        legalMovesArr[9]
        legalMoves(l_board, legalMovesArr)
        FOR i = 0 to i = 8 do
            IF (legalMovesArr[i])
                int tempBoard[9]
                curBoard(l_board, tempBoard)
                putInBoard(tempBoard, i, O)
                val = min(largemin(tempBoard, depth-1, 1), val)
            END IF
        END FOR
        return val
    END IF
END FUNCTION

